(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{317:function(t,n,e){"use strict";e.r(n);var a=e(2),o=Object(a.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("p",[this._v('###引用数据类型(函数)\n函数是javascript中的一等公民。javascript中不分普通函数和构造函数。\n只存在函数的普通调用和构造调用。如果函数被普通调用，那即为普通函数。\n如果函数被构造调用，那即为构造函数。\na.原生函数\nString()\nNumber()\nBoolean()\nArray()\nObject()\nFunction()\nRegExp()\n---在实际情况中没有必要使用 new Object() 来创建对象，因为这样就无法像常量形式那样一次设定多个属性，而必须逐一设定\n---构造函数 Function 只在极少数情况下很有用，比如动态定义函数参数和函数体的时候，你基本上不会通过这种方式来定义函数\n---强烈建议使用常量形式（如 /^a*b+/g ）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为 JavaScript  引擎在代码执行前会对它们进行预编译和缓存。\n---与前面的构造函数不同， RegExp(..) 有时还是很有用的，比如动态定义正则表达式\nDate()\nError()\n---相较于其他原生构造函数， Date(..) 和 Error(..) 的用处要大很多，因为没有对应的常量形式来作为它们的替代。\n创建日期对象必须使用 new Date()\n创建错误对象使用 new Error（）\nfunction foo(x) {\nif (!x) {\nthrow new Error( "x wasn\'t provided" );\n}\n}\n注意：\nvar a = new String( "abc" );\ntypeof a; //  typeof a的类型是 "object" ，不是 "String"')]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[this._v('\tb.[[class]]\n\t\t所有 typeof 返回值为 object的对象都包含一个内部属性 [[Class]];\n\t\t这个属性无法直接访问，一般通过 Object.prototype.toString.call()方法来查看 。\n\t\t多数情况下，对象的内部的[[Class]] 属性和创建该对象的原生构造函数相对应\n\t\t\n\t\tObject.prototype.toString.call( [1,2,3] );\t\t// "[object Array]"\n\t\tObject.prototype.toString.call( /a/i );\t\t\t// "[object RegExp]"\n\t\t\n\t\t注意：基本数据类型居然也有对应的[[class]]\n\t\t\tObject.prototype.toString.call( null );\t\t// "[object Null]"\n\t\t\tObject.prototype.toString.call( undefined );// "[object Undefined]"\n\t\t\tObject.prototype.toString.call( "abc" );\t// "[object String]"\n\t\t\tObject.prototype.toString.call( 42 );\t\t// "[object Number]"\n\t\t\tObject.prototype.toString.call( true );\t\t// "[object Boolean]"\n\t\t\tObject.prototype.toString.call(function(){})// "[object Function]"\n\t\n\tc.基本数据类型的包装类----装包\n\t\t\t由于基本类型值没有 .length 和 .toString() 这样的属性和方法，\n\t\t需要通过封装对象才能访问，此时 JavaScript  会自动为基本类型值 包装 （ box或者 wrap）一个封装对象\n\t\t\tvar a = "abc";\n\t\t\ta.length; // 3\n\t\t\ta.toUpperCase(); // "ABC"\n\t\t\t如果需要经常用到这些字符串属性和方法，比如在 for 循环中使用 i < a.length ，那么从一开始就创建一个封装对象也许更为方便，\n\t\t\t这样 JavaScript  引擎就不用每次都自动创建了\n\t\t\t但实际证明这并不是一个好办法，因为浏览器已经为 .length 这样的常见情况做了性能优化，直接使用封装对象来 “ 提前优化 ” 代码 反而会降低执行效率 。\n\t\t\t一般情况下，我们不需要直接使用封装对象。最好的办法是让 JavaScript  引擎自己决定什么时候应该使用封装对象。\n\t\t\t换句话说，就是应该优先考虑使用 "abc" 和 42 这样的基本类型值，而非 new String("abc") 和 new Number(42) 。\n\t\n\td.基本数据类型的包装类----拆包\n\t\t如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数;\n\t\tvar a = new String( "abc" );\n\t\tvar b = new Number( 42 );\n\t\tvar c = new Boolean( true );\n\t\ta.valueOf(); // "abc"\n\t\tb.valueOf(); // 42\n\t\tc.valueOf(); // true\n\t\t\n\t\tvalueOf\t\n\t\t\tJavaScript 调用 valueOf() 方法用来把对象转换成原始类型的值（数值、字符串和布尔值）。 \n\t\t\t你很少需要自己调用此函数; JavaScript 会自动调用此函数当需要转换成一个原始值时。\n\t\t\t默认情况下, valueOf() 会被每个对象Object继承。每一个内置对象都会覆盖这个方法为了返回一个合理的值，\n\t\t\t如果对象没有原始值，valueOf() 就会返回对象自己\n\t\n\tc.自定义函数\n\td.回调函数\n\te.IIFE:Immediately Invoked Function Expression\n\t\t(function(){})()\n')])])])])}),[],!1,null,null,null);n.default=o.exports}}]);