(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{260:function(t,n,a){"use strict";a.r(n);var s=a(2),o=Object(s.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("p",[this._v("###概述\nECMAScript高级的三座大山\n1.作用域&作用域链(衍生运用)\n执行上下文&执行上下文栈\n闭包\nthis\n提升\n。。。\n2.原型&原型链\t(衍生运用)\n继承\n属性的查找规则\n3.异步&单线程\t(衍生运用)\n定时器")]),this._v(" "),t("p",[this._v("###javascript性能问题\njavascript本身就只是一个非常不起眼的语言，用来处理非常小众的问题。所以从设计之初它的性能就没有被重点考虑过。\n由于web时代的来临和Html5的兴起，这一切让javascript前所未有地成为焦点。自然它的功能和性能在大家的努力下都有了长\n足的进步。\n一方面javascript是解释性语言，运行时编译。另一方面，它是一种无类型语言（动态语言）。相比较而言，静态语言C++\nJava。他们在编译阶段就能够知道变量的类型。但是javascript语言的动态性没有办法在编译的时候就知道变量的类型。只能在\n运行时才能确定。在运算时计算和决定类型导致了javascript语言的运行效率比静态语言C++ Java都要低的很多。\njava:\nclass Object{\nint x;\nint y;\n}\nint add(Object obj1,Object obj2){\nreturn obj1.x"),t("em",[this._v("obj1.y + obj2.x")]),this._v("obj2.y;\n}\n在编译(.java --\x3e .class(JVM上运行！))阶段，编译器发现有两个对象obj1,obj2.\n在内存中分配地址\nooo ---\x3eobj1\t\t\t\t\txxx ---\x3eobj2\nooo为obj1的基地址\t\t\t\txxx为obj2的基地址\nint类型占据四个字节\t\t\t\tint类型占据四个字节\nx---\x3e ooo往后推四个字节\t\t\tx---\x3e xxx往后推四个字节\ny---\x3e x的地址值再往后四个字节\t\ty---\x3e x的地址值再往后四个字节\n在C++ Java等语言中，已事先知道存取的成员变量(属性)的类型，所以语言解释系统只要利用数组\n和位移来存取这些变量和方法的地址。位移信息使它只要几个机器语言指令，就可以存取变量，找出变量\n或执行其他任务。")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[this._v("\tjs:\n\t\tfunction add(obj1,obj2){\n\t\t\treturn obj1.x*obj1.y + obj2.x*obj2.y;\n\t\t}\n\t\t对于传统的javascript解释器，所有这一切都是解释执行。所以效率不会高到哪去我们也将javascript代码的处理分成两个阶段。\n\t\t\t---编译阶段。(做不了太多事情，javascript的编译一般就是在执行前的几微秒内进行)\n\t\t\t---执行阶段。\n\t\t对于javascript引擎来说，因为没有C++或者java这样的强类型语言的类型信息。所以javascript引擎的通常做法就是在分配基地址后使用\n\t\t键值对的形式来存储每一个对象。(典型的做法就是采用字符串)。之后访问对象的属性值时需要通过属性名的匹配来获取相应的值。\n\t\t(这一切都是在执行阶段处理的)\n\t\n\t归根结底,js性能的瓶颈在于如何获取对象属性值的具体位置？\n\t\t---相对于对象基地址的偏移？\n\t\t---分配基地址后通过匹配属性名查找属性值？\n")])])])])}),[],!1,null,null,null);n.default=o.exports}}]);