---
title: 4_引用数据类型(函数)
date: 2022-01-16 16:06:21
permalink: /pages/47ca9b/
categories:
  - javascript
tags:
  - 
---

###引用数据类型(函数)
		函数是javascript中的一等公民。javascript中不分普通函数和构造函数。
			只存在函数的普通调用和构造调用。如果函数被普通调用，那即为普通函数。
								         如果函数被构造调用，那即为构造函数。
		a.原生函数
			String()
			Number()
			Boolean()
			Array()
			Object()
			Function()
			RegExp()
				---在实际情况中没有必要使用 new Object() 来创建对象，因为这样就无法像常量形式那样一次设定多个属性，而必须逐一设定
				---构造函数 Function 只在极少数情况下很有用，比如动态定义函数参数和函数体的时候，你基本上不会通过这种方式来定义函数
				---强烈建议使用常量形式（如 /^a*b+/g ）来定义正则表达式，这样不仅语法简单，执行效率也更高，因为 JavaScript  引擎在代码执行前会对它们进行预编译和缓存。
				---与前面的构造函数不同， RegExp(..) 有时还是很有用的，比如动态定义正则表达式
			Date()
			Error()
				---相较于其他原生构造函数， Date(..) 和 Error(..) 的用处要大很多，因为没有对应的常量形式来作为它们的替代。
				创建日期对象必须使用 new Date() 
				创建错误对象使用 new Error（）
					function foo(x) {
						if (!x) {
							throw new Error( "x wasn't provided" );
						}
					}
			注意：
				var a = new String( "abc" );
				typeof a; //  typeof a的类型是 "object" ，不是 "String"
			
		b.[[class]]
			所有 typeof 返回值为 object的对象都包含一个内部属性 [[Class]];
			这个属性无法直接访问，一般通过 Object.prototype.toString.call()方法来查看 。
			多数情况下，对象的内部的[[Class]] 属性和创建该对象的原生构造函数相对应
			
			Object.prototype.toString.call( [1,2,3] );		// "[object Array]"
			Object.prototype.toString.call( /a/i );			// "[object RegExp]"
			
			注意：基本数据类型居然也有对应的[[class]]
				Object.prototype.toString.call( null );		// "[object Null]"
				Object.prototype.toString.call( undefined );// "[object Undefined]"
				Object.prototype.toString.call( "abc" );	// "[object String]"
				Object.prototype.toString.call( 42 );		// "[object Number]"
				Object.prototype.toString.call( true );		// "[object Boolean]"
				Object.prototype.toString.call(function(){})// "[object Function]"
		
		c.基本数据类型的包装类----装包
				由于基本类型值没有 .length 和 .toString() 这样的属性和方法，
			需要通过封装对象才能访问，此时 JavaScript  会自动为基本类型值 包装 （ box或者 wrap）一个封装对象
				var a = "abc";
				a.length; // 3
				a.toUpperCase(); // "ABC"
				如果需要经常用到这些字符串属性和方法，比如在 for 循环中使用 i < a.length ，那么从一开始就创建一个封装对象也许更为方便，
				这样 JavaScript  引擎就不用每次都自动创建了
				但实际证明这并不是一个好办法，因为浏览器已经为 .length 这样的常见情况做了性能优化，直接使用封装对象来 “ 提前优化 ” 代码 反而会降低执行效率 。
				一般情况下，我们不需要直接使用封装对象。最好的办法是让 JavaScript  引擎自己决定什么时候应该使用封装对象。
				换句话说，就是应该优先考虑使用 "abc" 和 42 这样的基本类型值，而非 new String("abc") 和 new Number(42) 。
		
		d.基本数据类型的包装类----拆包
			如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数;
			var a = new String( "abc" );
			var b = new Number( 42 );
			var c = new Boolean( true );
			a.valueOf(); // "abc"
			b.valueOf(); // 42
			c.valueOf(); // true
			
			valueOf	
				JavaScript 调用 valueOf() 方法用来把对象转换成原始类型的值（数值、字符串和布尔值）。 
				你很少需要自己调用此函数; JavaScript 会自动调用此函数当需要转换成一个原始值时。
				默认情况下, valueOf() 会被每个对象Object继承。每一个内置对象都会覆盖这个方法为了返回一个合理的值，
				如果对象没有原始值，valueOf() 就会返回对象自己
		
		c.自定义函数
		d.回调函数
		e.IIFE:Immediately Invoked Function Expression
			(function(){})()

